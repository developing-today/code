#!/usr/bin/env bash

SAVED_SHELL_OPTIONS=$(set +o)
restore_shell_options() {
  eval "$SAVED_SHELL_OPTIONS"
}
trap restore_shell_options EXIT
set -e

# System-wide content for .bash_profile can be added here (for all users specified)
bash_profile_global_content=$(cat << 'EOF'
# ============================================================== START OF AUTOMATICALLY GENERATED CODE ==============================================================
# NOTE: THIS FILE AUTOMATICALLY GENERATED BY 'setup-bash-for-user.sh'. DO NOT CHANGE ABOVE '# ============================================================== END OF AUTOMATICALLY GENERATED CODE =============================================================='.
# ============================================================== START OF SYSTEM-WIDE GENERATED CODE ==============================================================

# System-wide content for .bash_profile can be added below here:
alias c='nix-shell --command "code-insiders ."'
alias cn='code-insiders .'

# ============================================================== END OF SYSTEM-WIDE GENERATED CODE ==============================================================
EOF
)

# System-wide content for .bashrc can be added here (for all users specified)
bashrc_global_content=$(cat << 'EOF'
# ============================================================== START OF AUTOMATICALLY GENERATED CODE ==============================================================
# NOTE: THIS FILE AUTOMATICALLY GENERATED BY 'setup-bash-for-user.sh'. DO NOT CHANGE ABOVE '# ============================================================== END OF AUTOMATICALLY GENERATED CODE =============================================================='.
# ============================================================== START OF SYSTEM-WIDE GENERATED CODE ==============================================================

# System-wide content for .bashrc can be added below here:
[[ -f ~/.bash_profile ]] && . ~/.bash_profile

# ============================================================== END OF SYSTEM-WIDE GENERATED CODE ==============================================================
EOF
)

process_user() {
  username="$1"
  force="$2"

  if ! id -u "$username" >/dev/null 2>&1; then
    echo "error: User '$username' does not exist"
    return 1
  fi

  user_home=$(getent passwd "$username" | cut -d: -f6)

  # Per user content for .bash_profile can be added here using heredoc (inside user-specific loop)
  bash_profile_user_content=$(cat << EOF
# THIS FILE AUTOMATICALLY GENERATED BY 'setup-bash-for-user.sh'. DO NOT CHANGE ABOVE '# ============================================================== END OF AUTOMATICALLY GENERATED CODE =============================================================='.
# ============================================================== START OF PER-USER GENERATED CODE ==============================================================

# Per user content for .bash_profile can be added below here:

# ============================================================== END OF PER-USER GENERATED CODE ==============================================================
# NOTE: Only make manual changes after the following END banner:
# ============================================================== END OF AUTOMATICALLY GENERATED CODE ==============================================================
EOF
  )

  # Per user content for .bashrc can be added here using heredoc (inside user-specific loop)
  bashrc_user_content=$(cat << EOF
# THIS FILE AUTOMATICALLY GENERATED BY 'setup-bash-for-user.sh'. DO NOT CHANGE ABOVE '# ============================================================== END OF AUTOMATICALLY GENERATED CODE =============================================================='.
# ============================================================== START OF PER-USER GENERATED CODE ==============================================================

# Per user content for .bashrc can be added below here:

# ============================================================== END OF PER-USER GENERATED CODE ==============================================================
# NOTE: Only make manual changes after the following END banner:
# ============================================================== END OF AUTOMATICALLY GENERATED CODE ==============================================================
EOF
  )

 # Combined content for .bash_profile and .bashrc
  combined_bash_profile_content=$(echo -e "$bash_profile_global_content\n$bash_profile_user_content\n")
  combined_bashrc_content=$(echo -e "$bashrc_global_content\n$bashrc_user_content\n")

  # Create temporary files for check and push scripts
  check_script_file=$(mktemp)
  push_script_file=$(mktemp)

  # Create temporary files for expected content
  expected_bash_profile_file=$(mktemp)
  expected_bashrc_file=$(mktemp)

  # Define cleanup function
  cleanup() {
    rm -f "$check_script_file" "$push_script_file" "$expected_bash_profile_file" "$expected_bashrc_file"
  }
  trap cleanup EXIT

  # Write check script to temporary file
  cat << EOF > "$check_script_file"
echo "checking bash for user: '$username'"
run_push_script=true
error=false

echo "checking .bash_profile for user: '$username'"
if [ -f "$user_home/.bash_profile" ]; then
  echo -e "$combined_bash_profile_content" > "$expected_bash_profile_file"
  if diff -q "$expected_bash_profile_file" "$user_home/.bash_profile"; then
    echo "same .bash_profile for user: '$username'" #info
    run_push_script=false
  elif diff -q "$expected_bash_profile_file" <(head -n $(($(wc -l < "$expected_bash_profile_file") - 1)) "$user_home/.bash_profile"); then
    echo "is prefix .bash_profile for user: '$username'" #warn
    run_push_script=false
  else
    error=true
    echo "different .bash_profile for user: '$username'"
  fi
else
  echo "missing .bash_profile for user: '$username'"
fi

echo "checking .bashrc for user: '$username'"
if [ -f "$user_home/.bashrc" ]; then
  echo -e "$combined_bashrc_content" > "$expected_bashrc_file"
  if diff -q "$expected_bashrc_file" "$user_home/.bashrc"; then
    echo "same .bashrc for user: '$username'" #info
    run_push_script=false
  elif diff -q "$expected_bashrc_file" <(head -n $(($(wc -l < "$expected_bashrc_file") - 1)) "$user_home/.bashrc"); then
    echo "is prefix .bashrc for user: '$username'" #warn
    run_push_script=false
  else
    error=true
    echo "different .bashrc for user: '$username'"
  fi
else
  echo "missing .bashrc for user: '$username'"
fi

if \$error; then
  echo "error for user: '$username'"
  exit 1
fi

if \$run_push_script; then
  bash "$push_script_file" || exit $?
fi
EOF

  # Write push script to temporary file
  cat << EOF > "$push_script_file"
echo "push bash script start for user: '$username'"
echo "updating .bash_profile for user: '$username'"
echo "$combined_bash_profile_content" > "$user_home/.bash_profile"
chmod +x "$user_home/.bash_profile"
echo "updating .bashrc for user: '$username'"
echo "$combined_bashrc_content" > "$user_home/.bashrc"
chmod +x "$user_home/.bashrc"
echo "push bash script done for user: '$username'"
EOF

  # Check if --force is not set
  if ! $force; then
    SAVED_CHECK_SHELL_OPTIONS=$(set +o)
    set -e

    bash "$check_script_file"
    check_exit_code=$?

    eval "$SAVED_CHECK_SHELL_OPTIONS"

    if [ $check_exit_code -ne 0 ]; then
      echo "error checking bash for user: '$username', check exit: $check_exit_code"
      return $check_exit_code
    fi
  elif $run_push_script; then
    bash "$push_script_file" || return $?
  fi
}

force=false
args=()
for arg in "$@"; do
  if [ "$arg" == "--force" ]; then
    force=true
  else
    args+=("$arg")
  fi
done

echo "force flag: $force"
echo "other arguments: ${args[@]}"

# If the script needs root permissions, check if it's running as root
if [ "$EUID" -ne 0 ]; then
  # Check if any of the arguments is a user other than the current user
  needs_root=false
  for arg in "${args[@]}"; do
    if [ "$arg" != "$USER" ] && [ "$arg" != "--force" ]; then
      echo "root required"
      needs_root=true
      break
    fi
  done

  if $needs_root; then
    echo "not root, running the script using sudo"
    sudo "$0" "${args[@]}" # Rerun the script with the same arguments using sudo
    exit $?                # Exit with the status code of the sudo command
  fi
fi

# If no arguments left provided after checking for all other checks, use the current username
if [ "${#args[@]}" -eq 0 ]; then
  args=("$USER")
  echo "no user provided"
  echo "default user: ${args[@]}"
fi

# Initialize exit_code to 0
exit_code=0

if command -v parallel >/dev/null 2>&1; then
  echo "processing each user in parallel"
  parallel process_user {} $force "$bash_profile_global_content" "$bashrc_global_content" ::: "${args[@]}"
  exit_code=$?
else
  echo "processing each user sequentially"
  for username in "${args[@]}"; do
    process_user "$username" $force "$bash_profile_global_content" "$bashrc_global_content"
    user_exit_code=$?
    if [ $user_exit_code -ne 0 ]; then
      exit_code=$user_exit_code
    fi
  done
fi

echo "done processing users"
echo "exit $exit_code"

if [ $exit_code -ne 0 ]; then
  exit $exit_code
fi
